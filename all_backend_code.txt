-e 
=== ./src/test/java/com/example/miniproject/MiniProjectApplicationTests.java ===

package com.example.miniproject;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class MiniProjectApplicationTests {

    @Test
    void contextLoads() {
    }

}
-e 
=== ./src/main/java/com/example/miniproject/repository/SessionRepository.java ===

package com.example.miniproject.repository;

public class SessionRepository {
}
-e 
=== ./src/main/java/com/example/miniproject/config/SecurityConfig.java ===

package com.example.miniproject.config;

import com.example.miniproject.security.JwtAuthenticationFilter;
import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.method.configuration.EnableReactiveMethodSecurity;
import org.springframework.security.config.annotation.web.reactive.EnableWebFluxSecurity;
import org.springframework.security.config.web.server.SecurityWebFiltersOrder;
import org.springframework.security.config.web.server.ServerHttpSecurity;
import org.springframework.security.web.server.SecurityWebFilterChain;

@Configuration
@EnableWebFluxSecurity
@EnableReactiveMethodSecurity
@RequiredArgsConstructor
public class SecurityConfig {

    private final JwtAuthenticationFilter jwtAuthFilter;

    @Bean
    public SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
        return http
                .csrf().disable()
                .authorizeExchange()
                .pathMatchers("/api/auth/**").permitAll()
                .pathMatchers("/api/sessions/public/**").permitAll()
                .pathMatchers("/api/sessions/admin/**").hasRole("ADMIN")
                .pathMatchers("/api/sessions/**").hasRole("USER")
                .anyExchange().authenticated()
                .and()
                .addFilterAt(jwtAuthFilter, SecurityWebFiltersOrder.AUTHENTICATION)
                .build();
    }
}-e 
=== ./src/main/java/com/example/miniproject/config/StorageConfig.java ===

package com.example.miniproject.config;

import com.amazonaws.auth.AWSStaticCredentialsProvider;
import com.amazonaws.auth.BasicAWSCredentials;
import com.amazonaws.client.builder.AwsClientBuilder;
import com.amazonaws.services.s3.AmazonS3;
import com.amazonaws.services.s3.AmazonS3ClientBuilder;
import com.amazonaws.services.s3.transfer.TransferManager;
import com.amazonaws.services.s3.transfer.TransferManagerBuilder;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.jdbc.DataSourceBuilder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.jdbc.core.JdbcTemplate;

import javax.sql.DataSource;

@Configuration
public class StorageConfig {
    @Value("${aws.access.key.id}")
    private String accessKeyId;

    @Value("${aws.secret.access.key}")
    private String secretAccessKey;

    @Value("${aws.s3.region}")
    private String region;

    @Value("${spring.datasource.url}")
    private String dbUrl;

    @Value("${spring.datasource.username}")
    private String dbUsername;

    @Value("${spring.datasource.password}")
    private String dbPassword;

    @Value("${aws.s3.endpoint:#{null}}")
    private String endpoint;

    @Bean
    public AmazonS3 amazonS3() {
        BasicAWSCredentials awsCreds = new BasicAWSCredentials(accessKeyId, secretAccessKey);

        AmazonS3ClientBuilder builder = AmazonS3ClientBuilder.standard()
                .withCredentials(new AWSStaticCredentialsProvider(awsCreds));

        // 如果指定了endpoint，使用LocalStack
        if (endpoint != null && !endpoint.isEmpty()) {
            builder.withEndpointConfiguration(
                    new AwsClientBuilder.EndpointConfiguration(endpoint, region)
            ).withPathStyleAccessEnabled(true);
        } else {
            builder.withRegion(region);
        }

        return builder.build();
    }

    @Bean
    public TransferManager transferManager(AmazonS3 amazonS3){
        return TransferManagerBuilder.standard()
                .withS3Client(amazonS3)
                .withMultipartUploadThreshold((long) (5 * 1024 * 1024))
                .build();
    }

    @Bean
    public DataSource dataSource() {
        return DataSourceBuilder.create()
                .url(dbUrl)
                .username(dbUsername)
                .password(dbPassword)
                .build();
    }

    @Bean
    public JdbcTemplate jdbcTemplate(DataSource dataSource) {
        return new JdbcTemplate(dataSource);
    }

}
-e 
=== ./src/main/java/com/example/miniproject/config/KafkaConfig.java ===

package com.example.miniproject.config;

import com.example.miniproject.model.SessionEvent;
import org.apache.kafka.clients.consumer.ConsumerConfig;
import org.apache.kafka.clients.producer.ProducerConfig;
import org.apache.kafka.common.serialization.StringDeserializer;
import org.apache.kafka.common.serialization.StringSerializer;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.kafka.config.ConcurrentKafkaListenerContainerFactory;
import org.springframework.kafka.core.*;
import org.springframework.kafka.support.serializer.JsonDeserializer;
import org.springframework.kafka.support.serializer.JsonSerializer;

import java.util.HashMap;
import java.util.Map;

@Configuration
public class KafkaConfig {

    @Value("${spring.kafka.boostrap-servers}")
    private String bootstrapServers;

    @Value("${spring.kafka.consumer.group-id}")
    private String groupId;

    @Bean
    public ProducerFactory<String, SessionEvent> producerFactory() {
        Map<String, Object> config = new HashMap<>();
        config.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);
        config.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class);
        config.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, JsonSerializer.class);
        config.put(ProducerConfig.ACKS_CONFIG, "all");// Wait for all replicas to acknowledge
        config.put(ProducerConfig.RETRIES_CONFIG, 3); // Number of retries
        config.put(ProducerConfig.RETRY_BACKOFF_MS_CONFIG, 1000); // Backoff time between retries
        config.put(ProducerConfig.ENABLE_IDEMPOTENCE_CONFIG, true);
        return new DefaultKafkaProducerFactory<>(config);
    }

    @Bean
    public ConsumerFactory<String, SessionEvent> consumerFactory(){
        Map<String, Object> config = new HashMap<>();
        config.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);
        config.put(ConsumerConfig.GROUP_ID_CONFIG, groupId);
        config.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class);
        config.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, JsonDeserializer.class);
        config.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, "earliest");

        return new DefaultKafkaConsumerFactory<>(
                config,
                new StringDeserializer(),
                new JsonDeserializer<>(SessionEvent.class)
        );
    }

    @Bean
    ConcurrentKafkaListenerContainerFactory<String, SessionEvent> kafkaListenerContainerFactory() {
        ConcurrentKafkaListenerContainerFactory<String, SessionEvent> factory = new ConcurrentKafkaListenerContainerFactory<>();
        factory.setConsumerFactory(consumerFactory());
        return factory;
    }

    @Bean
    public KafkaTemplate<String, SessionEvent> kafkaTemplate() {
        return new KafkaTemplate<>(producerFactory());
    }
}
-e 
=== ./src/main/java/com/example/miniproject/config/RedisConfig.java ===

package com.example.miniproject.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;
import org.springframework.data.redis.connection.ReactiveRedisConnectionFactory;
import org.springframework.data.redis.core.ReactiveRedisTemplate;
import org.springframework.data.redis.serializer.RedisSerializationContext;
import org.springframework.data.redis.serializer.StringRedisSerializer;

@Configuration
public class RedisConfig {

    @Bean
    @Primary // 添加@Primary注解表明这是首选bean
    public ReactiveRedisTemplate<String, String> jwtRedisTemplate(
            ReactiveRedisConnectionFactory factory) {
        StringRedisSerializer serializer = new StringRedisSerializer();
        RedisSerializationContext<String, String> serializationContext =
                RedisSerializationContext.<String, String>newSerializationContext()
                        .key(serializer)
                        .value(serializer)
                        .hashKey(serializer)
                        .hashValue(serializer)
                        .build();

        return new ReactiveRedisTemplate<>(factory, serializationContext);
    }
}-e 
=== ./src/main/java/com/example/miniproject/config/JwtConfig.java ===

package com.example.miniproject.config;

import io.jsonwebtoken.SignatureAlgorithm;
import io.jsonwebtoken.security.Keys;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.security.KeyPair;
import java.security.KeyPairGenerator;

@Configuration
public class JwtConfig {

    @Value("${jwt.expiration}")
    private Long jwtExpiration;

    @Bean
    public KeyPair keyPair() {
        return Keys.keyPairFor(SignatureAlgorithm.ES256);
    }

    @Bean
    public Long getJwtExpiration(){
        return jwtExpiration;
    }
}
-e 
=== ./src/main/java/com/example/miniproject/security/JwtAuthenticationFilter.java ===

package com.example.miniproject.security;

import com.example.miniproject.service.JwtService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpHeaders;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.ReactiveSecurityContextHolder;
import org.springframework.stereotype.Component;
import org.springframework.web.server.ServerWebExchange;
import org.springframework.web.server.WebFilter;
import org.springframework.web.server.WebFilterChain;
import reactor.core.publisher.Mono;

@Component
@RequiredArgsConstructor
public class JwtAuthenticationFilter implements WebFilter {

    private final JwtService jwtService;

    @Override
    public Mono<Void> filter(ServerWebExchange exchange, WebFilterChain chain) {
        String authHeader = exchange.getRequest()
                .getHeaders()
                .getFirst(HttpHeaders.AUTHORIZATION);

        if (authHeader == null || !authHeader.startsWith("Bearer ")) {
            return chain.filter(exchange);
        }

        String jwt = authHeader.substring(7);
        return jwtService.validateToken(jwt)
                .flatMap(claims -> {
                    String username = claims.getSubject();
                    UsernamePasswordAuthenticationToken auth =
                            new UsernamePasswordAuthenticationToken(
                                    username,
                                    null,
                                    jwtService.getAuthorities(claims)
                            );
                    return chain.filter(exchange)
                            .contextWrite(ReactiveSecurityContextHolder.withAuthentication(auth));
                })
                .onErrorResume(e -> chain.filter(exchange));
    }
}
-e 
=== ./src/main/java/com/example/miniproject/controller/SessionAnalysisController.java ===

package com.example.miniproject.controller;

import com.example.miniproject.model.SessionEvent;
import com.example.miniproject.model.SessionAnalytics;
import com.example.miniproject.service.EventProcessingService;
import com.example.miniproject.service.StorageService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;
import reactor.core.publisher.Mono;

import java.util.ArrayList;
import java.util.List;
import java.util.OptionalDouble;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/api/sessions")
@RequiredArgsConstructor
public class SessionAnalysisController {

    private final EventProcessingService eventProcessingService;
    private final StorageService storageService;

    @PostMapping("/events")
    @PreAuthorize("hasRole('USER')")
    public Mono<ResponseEntity<Void>> publishEvent(@RequestBody SessionEvent event) {
        return Mono.fromRunnable(() -> eventProcessingService.publishEvent(event))
                .thenReturn(ResponseEntity.ok().build());
    }

    @GetMapping("/{sessionId}/events")
    @PreAuthorize("hasRole('USER')")
    public Mono<ResponseEntity<List<SessionEvent>>> getSessionEvents(
            @PathVariable String sessionId,
            @RequestParam(required = false) String eventType) {

        return Mono.fromCallable(() -> {
            List<SessionEvent> events = storageService.getRecentEvents(sessionId);
            if (eventType != null) {
                events = events.stream()
                        .filter(e -> e.getEventType().equals(eventType))
                        .collect(Collectors.toList());
            }
            return ResponseEntity.ok(events);
        });
    }

    @GetMapping("/{sessionId}/analytics")
    @PreAuthorize("hasRole('USER')")
    public Mono<ResponseEntity<SessionAnalytics>> getSessionAnalytics(
            @PathVariable String sessionId) {

        return Mono.fromCallable(() -> {
            List<SessionEvent> events = storageService.getRecentEvents(sessionId);
            SessionAnalytics analytics = calculateAnalytics(events);
            return ResponseEntity.ok(analytics);
        });
    }

    @GetMapping("/admin/all-analytics")
    @PreAuthorize("hasRole('ADMIN')")
    public Mono<ResponseEntity<List<SessionAnalytics>>> getAllSessionsAnalytics() {
        // 实现管理员级别的分析功能
        return Mono.just(ResponseEntity.ok(new ArrayList<>())); // 使用兼容性更好的空ArrayList
    }

    private SessionAnalytics calculateAnalytics(List<SessionEvent> events) {
        SessionAnalytics analytics = new SessionAnalytics();

        // Calculate average startup time
        OptionalDouble avgStartupTime = events.stream()
                .filter(e -> e.getMetrics().getStartupTimeMs() != null)
                .mapToLong(e -> e.getMetrics().getStartupTimeMs())
                .average();
        analytics.setAverageStartupTimeMs(avgStartupTime.orElse(0.0));

        // Calculate total buffering time
        long totalBuffering = events.stream()
                .filter(e -> e.getMetrics().getBufferingDurationMs() != null)
                .mapToLong(e -> e.getMetrics().getBufferingDurationMs())
                .sum();
        analytics.setTotalBufferingMs(totalBuffering);

        // Calculate average bitrate
        OptionalDouble avgBitrate = events.stream()
                .filter(e -> e.getMetrics().getBitrate() != null)
                .mapToInt(e -> e.getMetrics().getBitrate())
                .average();
        analytics.setAverageBitrateKbps(avgBitrate.orElse(0.0));

        // Count errors
        long errorCount = events.stream()
                .mapToInt(e -> e.getMetrics().getErrorCount())
                .sum();
        analytics.setTotalErrors(errorCount);

        return analytics;
    }
}-e 
=== ./src/main/java/com/example/miniproject/controller/AuthController.java ===

package com.example.miniproject.controller;

import com.example.miniproject.model.AuthRequest;
import com.example.miniproject.model.AuthResponse;
import com.example.miniproject.service.JwtService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import reactor.core.publisher.Mono;

import java.util.Arrays;

@RestController
@RequestMapping("/api/auth")
@RequiredArgsConstructor
public class AuthController {

    private final JwtService jwtService;

    @PostMapping("/login")
    public Mono<ResponseEntity<AuthResponse>> login(@RequestBody AuthRequest request) {
        // In a real application, you would validate credentials here
        // For demo purposes, we're just generating a token
        String token = jwtService.generateToken(
                request.getUsername(),
                Arrays.asList("ROLE_USER")
        );

        return Mono.just(ResponseEntity.ok(new AuthResponse(token)));
    }

    @PostMapping("/logout")
    public Mono<ResponseEntity<Void>> logout(@RequestHeader("Authorization") String authHeader) {
        if (authHeader != null && authHeader.startsWith("Bearer ")) {
            String token = authHeader.substring(7);
            jwtService.blacklistToken(token);
        }
        return Mono.just(ResponseEntity.ok().build());
    }
}
-e 
=== ./src/main/java/com/example/miniproject/model/SessionMetadata.java ===

package com.example.miniproject.model;

public class SessionMetadata {
}
-e 
=== ./src/main/java/com/example/miniproject/model/SessionEvent.java ===

package com.example.miniproject.model;

import lombok.Data;
import javax.persistence.*;
import java.io.Serializable;
import java.time.Instant;

@Data
@Entity
@Table(name = "session_events")
public class SessionEvent implements Serializable {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private String sessionId;

    @Column(nullable = false)
    private String eventType;

    @Column(nullable = false)
    private Instant timestamp;

    @Embedded
    private QualityMetrics metrics;

    private String deviceType;
    private String region;
    private String contentId;

}
-e 
=== ./src/main/java/com/example/miniproject/model/SessionAnalytics.java ===

package com.example.miniproject.model;

import lombok.Data;

@Data
public class SessionAnalytics {
    private double averageStartupTimeMs;
    private long totalBufferingMs;
    private double averageBitrateKbps;
    private long totalErrors;
}-e 
=== ./src/main/java/com/example/miniproject/model/AuthResponse.java ===

package com.example.miniproject.model;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class AuthResponse {
    private String token;
}
-e 
=== ./src/main/java/com/example/miniproject/model/AuthRequest.java ===

package com.example.miniproject.model;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class AuthRequest {
    private String username;
    private String password;
}-e 
=== ./src/main/java/com/example/miniproject/model/QualityMetrics.java ===

package com.example.miniproject.model;

import lombok.Data;
import javax.persistence.Embeddable;


@Data
@Embeddable
public class QualityMetrics {
    private Long startupTimeMs;
    private Long bufferingDurationMs;
    private Long endTimeMs;
    private Integer bitrate;
    private Double bufferingRatio;
    private Integer errorCount;

}
-e 
=== ./src/main/java/com/example/miniproject/MiniProjectApplication.java ===

package com.example.miniproject;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class MiniProjectApplication {

    public static void main(String[] args) {
        SpringApplication.run(MiniProjectApplication.class, args);
    }

}
-e 
=== ./src/main/java/com/example/miniproject/service/JwtService.java ===

package com.example.miniproject.service;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
import lombok.RequiredArgsConstructor;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.data.redis.core.ReactiveRedisTemplate;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.stereotype.Service;
import reactor.core.publisher.Mono;

import java.security.KeyPair;
import java.time.Duration;
import java.util.Date;
import java.util.List;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
public class JwtService {

    private final KeyPair keyPair;

    @Qualifier("jwtRedisTemplate") // 使用@Qualifier指定要注入的bean
    private final ReactiveRedisTemplate<String, String> redisTemplate;

    private final Long jwtExpiration;

    private static final String TOKEN_BLACKLIST_PREFIX = "token:blacklist:";
    private static final String TOKEN_CACHE_PREFIX = "token:valid:";

    public String generateToken(String username, List<String> roles) {
        Date now = new Date();
        Date expiryDate = new Date(now.getTime() + jwtExpiration);

        String token = Jwts.builder()
                .setSubject(username)
                .claim("roles", roles)
                .setIssuedAt(now)
                .setExpiration(expiryDate)
                .signWith(keyPair.getPrivate())
                .compact();

        // 缓存有效令牌
        redisTemplate.opsForValue()
                .set(TOKEN_CACHE_PREFIX + token, "valid", Duration.ofMillis(jwtExpiration))
                .subscribe();

        return token;
    }

    public Mono<Claims> validateToken(String token) {
        // 首先检查令牌是否被列入黑名单
        return redisTemplate.hasKey(TOKEN_BLACKLIST_PREFIX + token)
                .flatMap(isBlacklisted -> {
                    if (isBlacklisted) {
                        return Mono.error(new RuntimeException("Token is blacklisted"));
                    }

                    // 检查令牌是否在缓存中
                    return redisTemplate.opsForValue().get(TOKEN_CACHE_PREFIX + token)
                            .flatMap(cached -> {
                                if (cached != null) {
                                    return parseToken(token);
                                }

                                // 如果不在缓存中，验证并缓存（如果有效）
                                return parseToken(token)
                                        .doOnSuccess(claims ->
                                                redisTemplate.opsForValue()
                                                        .set(TOKEN_CACHE_PREFIX + token,
                                                                "valid",
                                                                Duration.ofMillis(jwtExpiration))
                                                        .subscribe()
                                        );
                            });
                });
    }

    private Mono<Claims> parseToken(String token) {
        try {
            Claims claims = Jwts.parserBuilder()
                    .setSigningKey(keyPair.getPublic())
                    .build()
                    .parseClaimsJws(token)
                    .getBody();
            return Mono.just(claims);
        } catch (Exception e) {
            return Mono.error(e);
        }
    }

    public void blacklistToken(String token) {
        // 将令牌添加到黑名单，保持与原令牌相同的过期时间
        redisTemplate.opsForValue()
                .set(TOKEN_BLACKLIST_PREFIX + token,
                        "blacklisted",
                        Duration.ofMillis(jwtExpiration))
                .subscribe();

        // 如果存在，则从有效缓存中删除
        redisTemplate.delete(TOKEN_CACHE_PREFIX + token).subscribe();
    }

    public List<GrantedAuthority> getAuthorities(Claims claims) {
        @SuppressWarnings("unchecked")
        List<String> roles = claims.get("roles", List.class);
        return roles.stream()
                .map(SimpleGrantedAuthority::new)
                .collect(Collectors.toList());
    }

    // 为特定用户和角色生成带有自定义过期时间的令牌
    public String generateTokenWithCustomExpiration(String username, List<String> roles, long customExpirationMs) {
        Date now = new Date();
        Date expiryDate = new Date(now.getTime() + customExpirationMs);

        String token = Jwts.builder()
                .setSubject(username)
                .claim("roles", roles)
                .setIssuedAt(now)
                .setExpiration(expiryDate)
                .signWith(keyPair.getPrivate())
                .compact();

        // 缓存有效令牌，使用自定义过期时间
        redisTemplate.opsForValue()
                .set(TOKEN_CACHE_PREFIX + token, "valid", Duration.ofMillis(customExpirationMs))
                .subscribe();

        return token;
    }
}-e 
=== ./src/main/java/com/example/miniproject/service/AuthenticationService.java ===

package com.example.miniproject.service;

public class AuthenticationService {
}
-e 
=== ./src/main/java/com/example/miniproject/service/EventProcessingService.java ===

package com.example.miniproject.service;

import com.example.miniproject.model.SessionEvent;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.kafka.annotation.KafkaListener;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.stereotype.Service;

@Slf4j
@Service
@RequiredArgsConstructor
public class EventProcessingService {

    private final KafkaTemplate<String, SessionEvent> kafkaTemplate;
    private final StorageService storageService;
    private static final String TOPIC = "session-events";
    private static final String DLQ_TOPIC = "session-events-dlq";

    public void publishEvent(SessionEvent event) {
        try{
            kafkaTemplate.send(TOPIC, event.getContentId(), event);
            log.info("Published event for session: {}", event.getContentId());
        }
        catch (Exception e){
            log.error("Error publishing event {}",e.getMessage());
            kafkaTemplate.send(DLQ_TOPIC, event.getContentId(), event);
        }
    }

    @KafkaListener(topics = TOPIC, groupId = "${spring.kafka.consumer.group-id}")
    public void processEvent(SessionEvent event){
        try{
            validateEvent(event);
            storageService.store(event);
            log.info("Processed event for session: {}", event.getContentId());
        }
        catch(Exception e){
            log.error("Error processing event {}",e.getMessage());
            kafkaTemplate.send(DLQ_TOPIC, event.getContentId(), event);
        }
    }

    private void validateEvent(SessionEvent event){
        if (event.getSessionId() == null || event.getEventType() == null){
            throw new IllegalArgumentException("Invalid event data");
        }
    }

}
-e 
=== ./src/main/java/com/example/miniproject/service/StorageService.java ===

package com.example.miniproject.service;

import com.amazonaws.services.s3.transfer.TransferManager;
import com.amazonaws.services.s3.transfer.Upload;
import com.example.miniproject.model.QualityMetrics;
import com.example.miniproject.model.SessionEvent;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Service;

import javax.transaction.Transactional;
import java.io.ByteArrayInputStream;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.List;
import java.util.concurrent.CompletableFuture;


@Slf4j
@Service
@RequiredArgsConstructor
public class StorageService {

    private final JdbcTemplate jdbcTemplate;
    private final TransferManager transferManager;
    private final ObjectMapper objectMapper;

    @Value("${aws.s3.bucket}")
    private String bucketName;

    private static final int RETENTION_DAYS = 7;

    @Transactional
    public void storeEvent(SessionEvent event){
        String sql = "INSERT INTO session_events (session_id, event_type, timestamp, " +
                "startup_time_ms, buffering_duration_ms, bitrate, buffering_ratio, " +
                "error_count, device_type, region, content_id) " +
                "VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";

        jdbcTemplate.update(sql,
                event.getSessionId(),
                event.getEventType(),
                event.getTimestamp(),
                event.getMetrics().getStartupTimeMs(),
                event.getMetrics().getBufferingDurationMs(),
                event.getMetrics().getBitrate(),
                event.getMetrics().getBufferingRatio(),
                event.getMetrics().getErrorCount(),
                event.getDeviceType(),
                event.getRegion(),
                event.getContentId()
        );

        if (isEventOld(event)){
            archiveToS3(event);
        }
    }

    private boolean isEventOld(SessionEvent event){
        return event.getTimestamp().isBefore(Instant.now().minus(RETENTION_DAYS, ChronoUnit.DAYS));
    }

    private void archiveToS3(SessionEvent event){
        try{
            String key = generateS3Key(event);
            String eventJson = objectMapper.writeValueAsString(event);
            ByteArrayInputStream inputStream = new ByteArrayInputStream(eventJson.getBytes());

            Upload upload = transferManager.upload(bucketName, key, inputStream, null);

            CompletableFuture.runAsync(() ->{
                try{
                    upload.waitForCompletion();
                    log.info("Successfully archived event to S3: {}", key);
                }catch (Exception e){
                    log.error("Error archived to S3: {}", e.getMessage());
                }
            });
        }catch (Exception e){
            log.error("Error preparing event for S3 archive: {}", e.getMessage());

        }
    }

    private String generateS3Key(SessionEvent event){
        Instant timestamp = event.getTimestamp();
        return String.format("%tY/%tm/%td/%s/%s-%s.json",
                timestamp, timestamp, timestamp,
                event.getSessionId(),
                event.getEventType(),
                timestamp.toEpochMilli());
    }

    public List<SessionEvent> getRecentEvents(String sessionId){
        String sql = "SELECT * FROM session_events WHERE session_id = ?" +
                " AND timestamp > ? ORDER BY timestamp DESC";

        return jdbcTemplate.query(sql,
                (rs, rowNum) -> {
                    SessionEvent event = new SessionEvent();
                    event.setId(rs.getLong("Id"));
                    event.setSessionId(rs.getString("session_id"));
                    event.setEventType(rs.getString("event_type"));
                    event.setTimestamp(rs.getTimestamp("event_timestamp").toInstant());
                    event.setDeviceType(rs.getString("device_type"));
                    event.setRegion(rs.getString("region"));
                    event.setContentId(rs.getString("content_id"));

                    QualityMetrics metrics = new QualityMetrics();
                    metrics.setStartupTimeMs(rs.getLong("startup_time_ms"));
                    metrics.setBufferingDurationMs(rs.getLong("buffering_duration_ms"));
                    metrics.setBitrate(rs.getInt("bitrate"));
                    metrics.setBufferingRatio(rs.getDouble("buffering_ratio"));
                    metrics.setErrorCount(rs.getInt("error_count"));

                    event.setMetrics(metrics);
                    return event;
                }, sessionId, Instant.now().minus(RETENTION_DAYS, ChronoUnit.DAYS));

    }


}
